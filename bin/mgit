#!/usr/bin/env ruby
# frozen_string_literal: true

require 'thor'
require 'launchy'
require 'fileutils' # https://www.rubyguides.com/2015/05/working-with-files-ruby/

require_relative '../lib/git'
require_relative '../lib/issue'

# MgitCLI handles all the subcommands for the mGit CLI.
# TODO: Ensure all commands are run from the project root directory.
class MgitCLI < Thor
  class_option :force, {
    type: :boolean,
    aliases: '-f',
    desc: 'Assume "yes" as answer to all prompts and run non-interactively'
  }
  class_option :debug, type: :boolean, desc: 'Enable debug mode'

  def self.exit_on_failure?
    true
  end

  # Branch command

  desc 'branch <issueID>', 'Create a branch using issue ID and title'
  long_desc <<~LONGDESC
    The new branch name is taken from the title of the issue found.
    The new branch is created off of the --base-branch or the default base branch.
  LONGDESC
  method_option :base_branch, desc: 'the base branch to perform this action on'
  def branch(issue_id)
    base_branch = options[:base_branch] || Git.default_base_branch
    issue = Issue.from_tracker(issue_id)

    # TODO: Extract private method: create_branch(name, base_branch)
    prompt = "Create #{emphasize(issue.branch_name)} branch from #{emphasize(base_branch)}?"
    if options.force? || yes?(prompt)
      Git.create_branch(base_branch, issue.branch_name) # TODO: Handle errors, same as Git.current_branch()
      done
    else
      skip('Branch not created')
    end
  rescue StandardError => e # TODO: Specify error types
    # TODO: Extract private method: fail_with_error(e)
    fail options.debug? ? e : e.to_s.split("\n")[0]
  end

  # Commit command

  desc 'commit', 'Create a commit and push to GitHub'
  long_desc <<~LONGDESC
    All of the un-staged files are added, committed and pushed to GitHub.
    The commit message is extracted from the branch name if one is not supplied
    using the --message option. This command does the following:

      - Add all file (if commit was created)
      - Commit the changes (if commit was created)
      - Push changes to remote (if commit was created)
  LONGDESC
  method_option :message, desc: 'the commit message'
  method_option :issue_id, desc: 'the ID of the issue being worked on'
  def commit
    current_branch, stderr, status = Git.current_branch()
    raise stderr unless status.success?

    # Set commit message.
    message = options[:message]
    unless message
      # TODO: Extract private method: issue = get_issue(current_branch)
      issue = if options[:issue_id]
                Issue.from_tracker(options[:issue_id])
              else
                Issue.from_branch(current_branch)
              end
      message = issue.to_s
    end

    # Ask to create commit.
    # TODO: Extract private method: create_commit(message, current_branch)
    say(%(The commit message will be "#{emphasize(message)}")) if message
    prompt = "Commit all changes to the #{emphasize(current_branch)} branch?"
    if options.force? || yes?(prompt)
      Git.commit_all(message) # TODO: Handle errors, same as Git.current_branch()
      Git.push(current_branch) # TODO: Handle errors, same as Git.current_branch()
      done
    else
      skip('Changes not committed')
    end
  rescue StandardError => e # TODO: Specify error types
    # TODO: Extract private method: fail_with_error(e)
    fail options.debug? ? e : e.to_s.split("\n")[0]
  end

  # Init command

  desc 'init', 'Initialize local repository and push to remote'
  long_desc <<~LONGDESC
    This command is idempotent and it will prompt you before commiting changes and
    pushing them to the remote repo. This command does the following:

      - Create .gitignore file (if not already created)
      - Initialize a git repo (if not already intialized)
      - Asks to create an initial commit
      - Add all file (if user confirmed commit)
      - Commit the changes (if user confirmed commit)
      - Push changes to remote (if user confirmed commit)
  LONGDESC
  def init
    # Create .gitignore file.
    say('Creating .gitignore file...')
    if File.exist?('.gitignore')
      skip('.gitignore file already exists')
    else
      FileUtils.touch('.gitignore')
      done
    end

    # Initialize a git repo.
    say('Creating .gitignore file...')
    if Git.initialized?
      skip('Repo already intialized')
    else
      Git.init
      done
    end

    # Ask to create commit.
    # TODO: Extract private method: create_commit(message, current_branch)
    message = 'Initial commit'
    say(%(The commit message will be "#{emphasize(message)}")) if message
    prompt = "Commit all changes to the #{emphasize(current_branch)} branch?"
    if options.force? || yes?(prompt)
      Git.commit_all(message) # TODO: Handle errors, same as Git.current_branch()
      Git.push(current_branch) # TODO: Handle errors, same as Git.current_branch()
      done
    else
      skip('Changes not committed')
    end
  rescue StandardError => e # TODO: Specify error types
    # TODO: Extract private method: fail_with_error(e)
    fail options.debug? ? e : e.to_s.split("\n")[0]
  end

  # Open command

  desc 'open', 'Open an issue in the default web browser'
  def open
    say('Opening issue...')
    stdout, stderr, status = Git.current_branch
    raise stderr unless status.success?

    Launchy.open(Issue.from_branch(stdout).web_url)
  rescue StandardError => e # TODO: Specify error types
    # TODO: Extract private method: fail_with_error(e)
    fail options.debug? ? e : e.to_s.split("\n")[0]
  end

  # Pull request command

  # TODO: Add pull_request alias for command
  desc 'pr', 'Create a GitHub Pull Request for the specified branch'
  long_desc <<~LONGDESC
    This command is idempotent and it will prompt you before commiting changes and
    pushing them to the remote repo. This command does the following:

      - Asks to create a commit
      - Add all file (if user confirmed commit)
      - Commit the changes (if user confirmed commit)
      - Rebase changes off base branch (if user confirms rebase)
      - Push changes to remote
      - Create the pull request on GitHub
  LONGDESC
  method_option :base_branch, desc: 'the base branch to perform this action on'
  method_option :message, desc: 'the commit message'
  def pr
    current_branch, stderr, status = Git.current_branch()
    raise stderr unless status.success?

    # Set commit message.
    message = options[:message]
    unless message
      # TODO: Extract private method: issue = get_issue(current_branch)
      issue = if options[:issue_id]
                Issue.from_tracker(options[:issue_id])
              else
                Issue.from_branch(current_branch)
              end
      message = issue.to_s
    end

    # Ask to create commit.
    # TODO: Extract private method: create_commit(message, current_branch)
    say(%(The commit message will be "#{emphasize(message)}")) if message
    prompt = "Commit all changes to the #{emphasize(current_branch)} branch?"
    if options.force? || yes?(prompt)
      Git.commit_all(message) # TODO: Handle errors, same as Git.current_branch()
      Git.push(current_branch) # TODO: Handle errors, same as Git.current_branch()
      done
    else
      skip('Changes not committed')
    end

    # Rebase changes on base branch.
    base_branch = options[:base_branch] || Git.default_base_branch
    prompt = "Update the #{emphasize(base_branch)} branch and rebase?"
    if options.force? || yes?(prompt)
    else
      skip("No rebase off #{emphasize(base_branch)}")
    end

    Git.push(current_branch) # TODO: Handle errors, same as Git.current_branch()

    # Create pull request.
    say('Opening pull request...')
    Git.pull_request(issue: issue)
  rescue StandardError => e # TODO: Specify error types
    # TODO: Extract private method: fail_with_error(e)
    fail options.debug? ? e : e.to_s.split("\n")[0]
  end

  private

  # TODO: Remove when commands are fully implemented.
  def todo(name)
    say('TODO: ', :yellow)
    say("Implement #{name}")
  end

  def fail(message)
    say('FAIL: ', %i[red bold])
    say(message)
    exit 1
  end

  def skip(message)
    say('SKIP: ', :yellow)
    say(message)
  end

  def done
    say('OK', %i[green bold])
  end

  def emphasize(message)
    set_color(message, :cyan)
  end
end

MgitCLI.start(ARGV)
